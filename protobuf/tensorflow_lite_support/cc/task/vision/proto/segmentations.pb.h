// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow_lite_support/cc/task/vision/proto/segmentations.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto;
namespace tflite {
namespace task {
namespace vision {
class Segmentation;
struct SegmentationDefaultTypeInternal;
extern SegmentationDefaultTypeInternal _Segmentation_default_instance_;
class SegmentationResult;
struct SegmentationResultDefaultTypeInternal;
extern SegmentationResultDefaultTypeInternal _SegmentationResult_default_instance_;
class Segmentation_ColoredLabel;
struct Segmentation_ColoredLabelDefaultTypeInternal;
extern Segmentation_ColoredLabelDefaultTypeInternal _Segmentation_ColoredLabel_default_instance_;
class Segmentation_ConfidenceMask;
struct Segmentation_ConfidenceMaskDefaultTypeInternal;
extern Segmentation_ConfidenceMaskDefaultTypeInternal _Segmentation_ConfidenceMask_default_instance_;
class Segmentation_ConfidenceMasks;
struct Segmentation_ConfidenceMasksDefaultTypeInternal;
extern Segmentation_ConfidenceMasksDefaultTypeInternal _Segmentation_ConfidenceMasks_default_instance_;
}  // namespace vision
}  // namespace task
}  // namespace tflite
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tflite {
namespace task {
namespace vision {

// ===================================================================


// -------------------------------------------------------------------

class SegmentationResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tflite.task.vision.SegmentationResult) */ {
 public:
  inline SegmentationResult() : SegmentationResult(nullptr) {}
  ~SegmentationResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentationResult(::google::protobuf::internal::ConstantInitialized);

  SegmentationResult(const SegmentationResult& from);
  SegmentationResult(SegmentationResult&& from) noexcept
    : SegmentationResult() {
    *this = ::std::move(from);
  }

  inline SegmentationResult& operator=(const SegmentationResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentationResult& operator=(SegmentationResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentationResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentationResult* internal_default_instance() {
    return reinterpret_cast<const SegmentationResult*>(
               &_SegmentationResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SegmentationResult& a, SegmentationResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentationResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentationResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentationResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentationResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentationResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SegmentationResult& from) {
    SegmentationResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentationResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tflite.task.vision.SegmentationResult";
  }
  protected:
  explicit SegmentationResult(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentationFieldNumber = 1,
  };
  // repeated .tflite.task.vision.Segmentation segmentation = 1;
  int segmentation_size() const;
  private:
  int _internal_segmentation_size() const;

  public:
  void clear_segmentation() ;
  ::tflite::task::vision::Segmentation* mutable_segmentation(int index);
  ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation >*
      mutable_segmentation();
  private:
  const ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation>& _internal_segmentation() const;
  ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation>* _internal_mutable_segmentation();
  public:
  const ::tflite::task::vision::Segmentation& segmentation(int index) const;
  ::tflite::task::vision::Segmentation* add_segmentation();
  const ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation >&
      segmentation() const;
  // @@protoc_insertion_point(class_scope:tflite.task.vision.SegmentationResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation > segmentation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto;
};// -------------------------------------------------------------------

class Segmentation_ConfidenceMask final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tflite.task.vision.Segmentation.ConfidenceMask) */ {
 public:
  inline Segmentation_ConfidenceMask() : Segmentation_ConfidenceMask(nullptr) {}
  ~Segmentation_ConfidenceMask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Segmentation_ConfidenceMask(::google::protobuf::internal::ConstantInitialized);

  Segmentation_ConfidenceMask(const Segmentation_ConfidenceMask& from);
  Segmentation_ConfidenceMask(Segmentation_ConfidenceMask&& from) noexcept
    : Segmentation_ConfidenceMask() {
    *this = ::std::move(from);
  }

  inline Segmentation_ConfidenceMask& operator=(const Segmentation_ConfidenceMask& from) {
    CopyFrom(from);
    return *this;
  }
  inline Segmentation_ConfidenceMask& operator=(Segmentation_ConfidenceMask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Segmentation_ConfidenceMask& default_instance() {
    return *internal_default_instance();
  }
  static inline const Segmentation_ConfidenceMask* internal_default_instance() {
    return reinterpret_cast<const Segmentation_ConfidenceMask*>(
               &_Segmentation_ConfidenceMask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Segmentation_ConfidenceMask& a, Segmentation_ConfidenceMask& b) {
    a.Swap(&b);
  }
  inline void Swap(Segmentation_ConfidenceMask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Segmentation_ConfidenceMask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Segmentation_ConfidenceMask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Segmentation_ConfidenceMask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Segmentation_ConfidenceMask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Segmentation_ConfidenceMask& from) {
    Segmentation_ConfidenceMask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Segmentation_ConfidenceMask* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tflite.task.vision.Segmentation.ConfidenceMask";
  }
  protected:
  explicit Segmentation_ConfidenceMask(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated float value = 1 [packed = true];
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField<float>& value() const;
  ::google::protobuf::RepeatedField<float>* mutable_value();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_value() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:tflite.task.vision.Segmentation.ConfidenceMask)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto;
};// -------------------------------------------------------------------

class Segmentation_ConfidenceMasks final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tflite.task.vision.Segmentation.ConfidenceMasks) */ {
 public:
  inline Segmentation_ConfidenceMasks() : Segmentation_ConfidenceMasks(nullptr) {}
  ~Segmentation_ConfidenceMasks() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Segmentation_ConfidenceMasks(::google::protobuf::internal::ConstantInitialized);

  Segmentation_ConfidenceMasks(const Segmentation_ConfidenceMasks& from);
  Segmentation_ConfidenceMasks(Segmentation_ConfidenceMasks&& from) noexcept
    : Segmentation_ConfidenceMasks() {
    *this = ::std::move(from);
  }

  inline Segmentation_ConfidenceMasks& operator=(const Segmentation_ConfidenceMasks& from) {
    CopyFrom(from);
    return *this;
  }
  inline Segmentation_ConfidenceMasks& operator=(Segmentation_ConfidenceMasks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Segmentation_ConfidenceMasks& default_instance() {
    return *internal_default_instance();
  }
  static inline const Segmentation_ConfidenceMasks* internal_default_instance() {
    return reinterpret_cast<const Segmentation_ConfidenceMasks*>(
               &_Segmentation_ConfidenceMasks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Segmentation_ConfidenceMasks& a, Segmentation_ConfidenceMasks& b) {
    a.Swap(&b);
  }
  inline void Swap(Segmentation_ConfidenceMasks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Segmentation_ConfidenceMasks* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Segmentation_ConfidenceMasks* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Segmentation_ConfidenceMasks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Segmentation_ConfidenceMasks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Segmentation_ConfidenceMasks& from) {
    Segmentation_ConfidenceMasks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Segmentation_ConfidenceMasks* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tflite.task.vision.Segmentation.ConfidenceMasks";
  }
  protected:
  explicit Segmentation_ConfidenceMasks(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceMaskFieldNumber = 1,
  };
  // repeated .tflite.task.vision.Segmentation.ConfidenceMask confidence_mask = 1;
  int confidence_mask_size() const;
  private:
  int _internal_confidence_mask_size() const;

  public:
  void clear_confidence_mask() ;
  ::tflite::task::vision::Segmentation_ConfidenceMask* mutable_confidence_mask(int index);
  ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ConfidenceMask >*
      mutable_confidence_mask();
  private:
  const ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation_ConfidenceMask>& _internal_confidence_mask() const;
  ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation_ConfidenceMask>* _internal_mutable_confidence_mask();
  public:
  const ::tflite::task::vision::Segmentation_ConfidenceMask& confidence_mask(int index) const;
  ::tflite::task::vision::Segmentation_ConfidenceMask* add_confidence_mask();
  const ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ConfidenceMask >&
      confidence_mask() const;
  // @@protoc_insertion_point(class_scope:tflite.task.vision.Segmentation.ConfidenceMasks)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ConfidenceMask > confidence_mask_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto;
};// -------------------------------------------------------------------

class Segmentation_ColoredLabel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tflite.task.vision.Segmentation.ColoredLabel) */ {
 public:
  inline Segmentation_ColoredLabel() : Segmentation_ColoredLabel(nullptr) {}
  ~Segmentation_ColoredLabel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Segmentation_ColoredLabel(::google::protobuf::internal::ConstantInitialized);

  Segmentation_ColoredLabel(const Segmentation_ColoredLabel& from);
  Segmentation_ColoredLabel(Segmentation_ColoredLabel&& from) noexcept
    : Segmentation_ColoredLabel() {
    *this = ::std::move(from);
  }

  inline Segmentation_ColoredLabel& operator=(const Segmentation_ColoredLabel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Segmentation_ColoredLabel& operator=(Segmentation_ColoredLabel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Segmentation_ColoredLabel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Segmentation_ColoredLabel* internal_default_instance() {
    return reinterpret_cast<const Segmentation_ColoredLabel*>(
               &_Segmentation_ColoredLabel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Segmentation_ColoredLabel& a, Segmentation_ColoredLabel& b) {
    a.Swap(&b);
  }
  inline void Swap(Segmentation_ColoredLabel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Segmentation_ColoredLabel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Segmentation_ColoredLabel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Segmentation_ColoredLabel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Segmentation_ColoredLabel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Segmentation_ColoredLabel& from) {
    Segmentation_ColoredLabel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Segmentation_ColoredLabel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tflite.task.vision.Segmentation.ColoredLabel";
  }
  protected:
  explicit Segmentation_ColoredLabel(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassNameFieldNumber = 4,
    kDisplayNameFieldNumber = 5,
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
  };
  // optional string class_name = 4;
  bool has_class_name() const;
  void clear_class_name() ;
  const std::string& class_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_class_name(Arg_&& arg, Args_... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* ptr);

  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(
      const std::string& value);
  std::string* _internal_mutable_class_name();

  public:
  // optional string display_name = 5;
  bool has_display_name() const;
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* ptr);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // optional uint32 r = 1;
  bool has_r() const;
  void clear_r() ;
  ::uint32_t r() const;
  void set_r(::uint32_t value);

  private:
  ::uint32_t _internal_r() const;
  void _internal_set_r(::uint32_t value);

  public:
  // optional uint32 g = 2;
  bool has_g() const;
  void clear_g() ;
  ::uint32_t g() const;
  void set_g(::uint32_t value);

  private:
  ::uint32_t _internal_g() const;
  void _internal_set_g(::uint32_t value);

  public:
  // optional uint32 b = 3;
  bool has_b() const;
  void clear_b() ;
  ::uint32_t b() const;
  void set_b(::uint32_t value);

  private:
  ::uint32_t _internal_b() const;
  void _internal_set_b(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tflite.task.vision.Segmentation.ColoredLabel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 75, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr class_name_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::uint32_t r_;
    ::uint32_t g_;
    ::uint32_t b_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto;
};// -------------------------------------------------------------------

class Segmentation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tflite.task.vision.Segmentation) */ {
 public:
  inline Segmentation() : Segmentation(nullptr) {}
  ~Segmentation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Segmentation(::google::protobuf::internal::ConstantInitialized);

  Segmentation(const Segmentation& from);
  Segmentation(Segmentation&& from) noexcept
    : Segmentation() {
    *this = ::std::move(from);
  }

  inline Segmentation& operator=(const Segmentation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Segmentation& operator=(Segmentation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Segmentation& default_instance() {
    return *internal_default_instance();
  }
  enum MaskOneofCase {
    kCategoryMask = 1,
    kConfidenceMasks = 4,
    MASK_ONEOF_NOT_SET = 0,
  };

  static inline const Segmentation* internal_default_instance() {
    return reinterpret_cast<const Segmentation*>(
               &_Segmentation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Segmentation& a, Segmentation& b) {
    a.Swap(&b);
  }
  inline void Swap(Segmentation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Segmentation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Segmentation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Segmentation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Segmentation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Segmentation& from) {
    Segmentation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Segmentation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "tflite.task.vision.Segmentation";
  }
  protected:
  explicit Segmentation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Segmentation_ConfidenceMask ConfidenceMask;
  typedef Segmentation_ConfidenceMasks ConfidenceMasks;
  typedef Segmentation_ColoredLabel ColoredLabel;

  // accessors -------------------------------------------------------

  enum : int {
    kColoredLabelsFieldNumber = 5,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kCategoryMaskFieldNumber = 1,
    kConfidenceMasksFieldNumber = 4,
  };
  // repeated .tflite.task.vision.Segmentation.ColoredLabel colored_labels = 5;
  int colored_labels_size() const;
  private:
  int _internal_colored_labels_size() const;

  public:
  void clear_colored_labels() ;
  ::tflite::task::vision::Segmentation_ColoredLabel* mutable_colored_labels(int index);
  ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ColoredLabel >*
      mutable_colored_labels();
  private:
  const ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation_ColoredLabel>& _internal_colored_labels() const;
  ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation_ColoredLabel>* _internal_mutable_colored_labels();
  public:
  const ::tflite::task::vision::Segmentation_ColoredLabel& colored_labels(int index) const;
  ::tflite::task::vision::Segmentation_ColoredLabel* add_colored_labels();
  const ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ColoredLabel >&
      colored_labels() const;
  // optional int32 width = 2;
  bool has_width() const;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // optional int32 height = 3;
  bool has_height() const;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // bytes category_mask = 1;
  bool has_category_mask() const;
  void clear_category_mask() ;
  const std::string& category_mask() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category_mask(Arg_&& arg, Args_... args);
  std::string* mutable_category_mask();
  PROTOBUF_NODISCARD std::string* release_category_mask();
  void set_allocated_category_mask(std::string* ptr);

  private:
  const std::string& _internal_category_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category_mask(
      const std::string& value);
  std::string* _internal_mutable_category_mask();

  public:
  // .tflite.task.vision.Segmentation.ConfidenceMasks confidence_masks = 4;
  bool has_confidence_masks() const;
  private:
  bool _internal_has_confidence_masks() const;

  public:
  void clear_confidence_masks() ;
  const ::tflite::task::vision::Segmentation_ConfidenceMasks& confidence_masks() const;
  PROTOBUF_NODISCARD ::tflite::task::vision::Segmentation_ConfidenceMasks* release_confidence_masks();
  ::tflite::task::vision::Segmentation_ConfidenceMasks* mutable_confidence_masks();
  void set_allocated_confidence_masks(::tflite::task::vision::Segmentation_ConfidenceMasks* value);
  void unsafe_arena_set_allocated_confidence_masks(::tflite::task::vision::Segmentation_ConfidenceMasks* value);
  ::tflite::task::vision::Segmentation_ConfidenceMasks* unsafe_arena_release_confidence_masks();

  private:
  const ::tflite::task::vision::Segmentation_ConfidenceMasks& _internal_confidence_masks() const;
  ::tflite::task::vision::Segmentation_ConfidenceMasks* _internal_mutable_confidence_masks();

  public:
  void clear_mask_oneof();
  MaskOneofCase mask_oneof_case() const;
  // @@protoc_insertion_point(class_scope:tflite.task.vision.Segmentation)
 private:
  class _Internal;
  void set_has_category_mask();
  void set_has_confidence_masks();

  inline bool has_mask_oneof() const;
  inline void clear_has_mask_oneof();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 5, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ColoredLabel > colored_labels_;
    ::int32_t width_;
    ::int32_t height_;
    union MaskOneofUnion {
      constexpr MaskOneofUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr category_mask_;
      ::tflite::task::vision::Segmentation_ConfidenceMasks* confidence_masks_;
    } mask_oneof_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SegmentationResult

// repeated .tflite.task.vision.Segmentation segmentation = 1;
inline int SegmentationResult::_internal_segmentation_size() const {
  return _internal_segmentation().size();
}
inline int SegmentationResult::segmentation_size() const {
  return _internal_segmentation_size();
}
inline void SegmentationResult::clear_segmentation() {
  _internal_mutable_segmentation()->Clear();
}
inline ::tflite::task::vision::Segmentation* SegmentationResult::mutable_segmentation(int index) {
  // @@protoc_insertion_point(field_mutable:tflite.task.vision.SegmentationResult.segmentation)
  return _internal_mutable_segmentation()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation >*
SegmentationResult::mutable_segmentation() {
  // @@protoc_insertion_point(field_mutable_list:tflite.task.vision.SegmentationResult.segmentation)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_segmentation();
}
inline const ::tflite::task::vision::Segmentation& SegmentationResult::segmentation(int index) const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.SegmentationResult.segmentation)
    return _internal_segmentation().Get(index);
}
inline ::tflite::task::vision::Segmentation* SegmentationResult::add_segmentation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::tflite::task::vision::Segmentation* _add = _internal_mutable_segmentation()->Add();
  // @@protoc_insertion_point(field_add:tflite.task.vision.SegmentationResult.segmentation)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation >&
SegmentationResult::segmentation() const {
  // @@protoc_insertion_point(field_list:tflite.task.vision.SegmentationResult.segmentation)
  return _internal_segmentation();
}
inline const ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation>&
SegmentationResult::_internal_segmentation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segmentation_;
}
inline ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation>*
SegmentationResult::_internal_mutable_segmentation() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.segmentation_;
}

// -------------------------------------------------------------------

// Segmentation_ConfidenceMask

// repeated float value = 1 [packed = true];
inline int Segmentation_ConfidenceMask::_internal_value_size() const {
  return _internal_value().size();
}
inline int Segmentation_ConfidenceMask::value_size() const {
  return _internal_value_size();
}
inline void Segmentation_ConfidenceMask::clear_value() {
  _internal_mutable_value()->Clear();
}
inline float Segmentation_ConfidenceMask::value(int index) const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.ConfidenceMask.value)
  return _internal_value().Get(index);
}
inline void Segmentation_ConfidenceMask::set_value(int index, float value) {
  _internal_mutable_value()->Set(index, value);
  // @@protoc_insertion_point(field_set:tflite.task.vision.Segmentation.ConfidenceMask.value)
}
inline void Segmentation_ConfidenceMask::add_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_value()->Add(value);
  // @@protoc_insertion_point(field_add:tflite.task.vision.Segmentation.ConfidenceMask.value)
}
inline const ::google::protobuf::RepeatedField<float>& Segmentation_ConfidenceMask::value() const {
  // @@protoc_insertion_point(field_list:tflite.task.vision.Segmentation.ConfidenceMask.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedField<float>* Segmentation_ConfidenceMask::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tflite.task.vision.Segmentation.ConfidenceMask.value)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_value();
}

inline const ::google::protobuf::RepeatedField<float>& Segmentation_ConfidenceMask::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedField<float>* Segmentation_ConfidenceMask::_internal_mutable_value() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// Segmentation_ConfidenceMasks

// repeated .tflite.task.vision.Segmentation.ConfidenceMask confidence_mask = 1;
inline int Segmentation_ConfidenceMasks::_internal_confidence_mask_size() const {
  return _internal_confidence_mask().size();
}
inline int Segmentation_ConfidenceMasks::confidence_mask_size() const {
  return _internal_confidence_mask_size();
}
inline void Segmentation_ConfidenceMasks::clear_confidence_mask() {
  _internal_mutable_confidence_mask()->Clear();
}
inline ::tflite::task::vision::Segmentation_ConfidenceMask* Segmentation_ConfidenceMasks::mutable_confidence_mask(int index) {
  // @@protoc_insertion_point(field_mutable:tflite.task.vision.Segmentation.ConfidenceMasks.confidence_mask)
  return _internal_mutable_confidence_mask()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ConfidenceMask >*
Segmentation_ConfidenceMasks::mutable_confidence_mask() {
  // @@protoc_insertion_point(field_mutable_list:tflite.task.vision.Segmentation.ConfidenceMasks.confidence_mask)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_confidence_mask();
}
inline const ::tflite::task::vision::Segmentation_ConfidenceMask& Segmentation_ConfidenceMasks::confidence_mask(int index) const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.ConfidenceMasks.confidence_mask)
    return _internal_confidence_mask().Get(index);
}
inline ::tflite::task::vision::Segmentation_ConfidenceMask* Segmentation_ConfidenceMasks::add_confidence_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::tflite::task::vision::Segmentation_ConfidenceMask* _add = _internal_mutable_confidence_mask()->Add();
  // @@protoc_insertion_point(field_add:tflite.task.vision.Segmentation.ConfidenceMasks.confidence_mask)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ConfidenceMask >&
Segmentation_ConfidenceMasks::confidence_mask() const {
  // @@protoc_insertion_point(field_list:tflite.task.vision.Segmentation.ConfidenceMasks.confidence_mask)
  return _internal_confidence_mask();
}
inline const ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation_ConfidenceMask>&
Segmentation_ConfidenceMasks::_internal_confidence_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.confidence_mask_;
}
inline ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation_ConfidenceMask>*
Segmentation_ConfidenceMasks::_internal_mutable_confidence_mask() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.confidence_mask_;
}

// -------------------------------------------------------------------

// Segmentation_ColoredLabel

// optional uint32 r = 1;
inline bool Segmentation_ColoredLabel::has_r() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Segmentation_ColoredLabel::clear_r() {
  _impl_.r_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Segmentation_ColoredLabel::r() const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.ColoredLabel.r)
  return _internal_r();
}
inline void Segmentation_ColoredLabel::set_r(::uint32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:tflite.task.vision.Segmentation.ColoredLabel.r)
}
inline ::uint32_t Segmentation_ColoredLabel::_internal_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.r_;
}
inline void Segmentation_ColoredLabel::_internal_set_r(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.r_ = value;
}

// optional uint32 g = 2;
inline bool Segmentation_ColoredLabel::has_g() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Segmentation_ColoredLabel::clear_g() {
  _impl_.g_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t Segmentation_ColoredLabel::g() const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.ColoredLabel.g)
  return _internal_g();
}
inline void Segmentation_ColoredLabel::set_g(::uint32_t value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:tflite.task.vision.Segmentation.ColoredLabel.g)
}
inline ::uint32_t Segmentation_ColoredLabel::_internal_g() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.g_;
}
inline void Segmentation_ColoredLabel::_internal_set_g(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.g_ = value;
}

// optional uint32 b = 3;
inline bool Segmentation_ColoredLabel::has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Segmentation_ColoredLabel::clear_b() {
  _impl_.b_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t Segmentation_ColoredLabel::b() const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.ColoredLabel.b)
  return _internal_b();
}
inline void Segmentation_ColoredLabel::set_b(::uint32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:tflite.task.vision.Segmentation.ColoredLabel.b)
}
inline ::uint32_t Segmentation_ColoredLabel::_internal_b() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.b_;
}
inline void Segmentation_ColoredLabel::_internal_set_b(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.b_ = value;
}

// optional string class_name = 4;
inline bool Segmentation_ColoredLabel::has_class_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Segmentation_ColoredLabel::clear_class_name() {
  _impl_.class_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Segmentation_ColoredLabel::class_name() const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.ColoredLabel.class_name)
  return _internal_class_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Segmentation_ColoredLabel::set_class_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.class_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.task.vision.Segmentation.ColoredLabel.class_name)
}
inline std::string* Segmentation_ColoredLabel::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:tflite.task.vision.Segmentation.ColoredLabel.class_name)
  return _s;
}
inline const std::string& Segmentation_ColoredLabel::_internal_class_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.class_name_.Get();
}
inline void Segmentation_ColoredLabel::_internal_set_class_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.class_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Segmentation_ColoredLabel::_internal_mutable_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.class_name_.Mutable( GetArenaForAllocation());
}
inline std::string* Segmentation_ColoredLabel::release_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tflite.task.vision.Segmentation.ColoredLabel.class_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.class_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.class_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Segmentation_ColoredLabel::set_allocated_class_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.class_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.class_name_.IsDefault()) {
          _impl_.class_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.task.vision.Segmentation.ColoredLabel.class_name)
}

// optional string display_name = 5;
inline bool Segmentation_ColoredLabel::has_display_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Segmentation_ColoredLabel::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Segmentation_ColoredLabel::display_name() const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.ColoredLabel.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Segmentation_ColoredLabel::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.task.vision.Segmentation.ColoredLabel.display_name)
}
inline std::string* Segmentation_ColoredLabel::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:tflite.task.vision.Segmentation.ColoredLabel.display_name)
  return _s;
}
inline const std::string& Segmentation_ColoredLabel::_internal_display_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_.Get();
}
inline void Segmentation_ColoredLabel::_internal_set_display_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Segmentation_ColoredLabel::_internal_mutable_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.display_name_.Mutable( GetArenaForAllocation());
}
inline std::string* Segmentation_ColoredLabel::release_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tflite.task.vision.Segmentation.ColoredLabel.display_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.display_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Segmentation_ColoredLabel::set_allocated_display_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.display_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.task.vision.Segmentation.ColoredLabel.display_name)
}

// -------------------------------------------------------------------

// Segmentation

// bytes category_mask = 1;
inline bool Segmentation::has_category_mask() const {
  return mask_oneof_case() == kCategoryMask;
}
inline void Segmentation::set_has_category_mask() {
  _impl_._oneof_case_[0] = kCategoryMask;
}
inline void Segmentation::clear_category_mask() {
  if (mask_oneof_case() == kCategoryMask) {
    _impl_.mask_oneof_.category_mask_.Destroy();
    clear_has_mask_oneof();
  }
}
inline const std::string& Segmentation::category_mask() const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.category_mask)
  return _internal_category_mask();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Segmentation::set_category_mask(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mask_oneof_case() != kCategoryMask) {
    clear_mask_oneof();

    set_has_category_mask();
    _impl_.mask_oneof_.category_mask_.InitDefault();
  }
  _impl_.mask_oneof_.category_mask_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.task.vision.Segmentation.category_mask)
}
inline std::string* Segmentation::mutable_category_mask() {
  std::string* _s = _internal_mutable_category_mask();
  // @@protoc_insertion_point(field_mutable:tflite.task.vision.Segmentation.category_mask)
  return _s;
}
inline const std::string& Segmentation::_internal_category_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (mask_oneof_case() != kCategoryMask) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.mask_oneof_.category_mask_.Get();
}
inline void Segmentation::_internal_set_category_mask(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mask_oneof_case() != kCategoryMask) {
    clear_mask_oneof();

    set_has_category_mask();
    _impl_.mask_oneof_.category_mask_.InitDefault();
  }
  _impl_.mask_oneof_.category_mask_.Set(value, GetArenaForAllocation());
}
inline std::string* Segmentation::_internal_mutable_category_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mask_oneof_case() != kCategoryMask) {
    clear_mask_oneof();

    set_has_category_mask();
    _impl_.mask_oneof_.category_mask_.InitDefault();
  }
  return _impl_.mask_oneof_.category_mask_.Mutable( GetArenaForAllocation());
}
inline std::string* Segmentation::release_category_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tflite.task.vision.Segmentation.category_mask)
  if (mask_oneof_case() != kCategoryMask) {
    return nullptr;
  }
  clear_has_mask_oneof();
  return _impl_.mask_oneof_.category_mask_.Release();
}
inline void Segmentation::set_allocated_category_mask(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_mask_oneof()) {
    clear_mask_oneof();
  }
  if (value != nullptr) {
    set_has_category_mask();
    _impl_.mask_oneof_.category_mask_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:tflite.task.vision.Segmentation.category_mask)
}

// .tflite.task.vision.Segmentation.ConfidenceMasks confidence_masks = 4;
inline bool Segmentation::has_confidence_masks() const {
  return mask_oneof_case() == kConfidenceMasks;
}
inline bool Segmentation::_internal_has_confidence_masks() const {
  return mask_oneof_case() == kConfidenceMasks;
}
inline void Segmentation::set_has_confidence_masks() {
  _impl_._oneof_case_[0] = kConfidenceMasks;
}
inline void Segmentation::clear_confidence_masks() {
  if (mask_oneof_case() == kConfidenceMasks) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mask_oneof_.confidence_masks_;
    }
    clear_has_mask_oneof();
  }
}
inline ::tflite::task::vision::Segmentation_ConfidenceMasks* Segmentation::release_confidence_masks() {
  // @@protoc_insertion_point(field_release:tflite.task.vision.Segmentation.confidence_masks)
  if (mask_oneof_case() == kConfidenceMasks) {
    clear_has_mask_oneof();
    ::tflite::task::vision::Segmentation_ConfidenceMasks* temp = _impl_.mask_oneof_.confidence_masks_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mask_oneof_.confidence_masks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tflite::task::vision::Segmentation_ConfidenceMasks& Segmentation::_internal_confidence_masks() const {
  return mask_oneof_case() == kConfidenceMasks
      ? *_impl_.mask_oneof_.confidence_masks_
      : reinterpret_cast<::tflite::task::vision::Segmentation_ConfidenceMasks&>(::tflite::task::vision::_Segmentation_ConfidenceMasks_default_instance_);
}
inline const ::tflite::task::vision::Segmentation_ConfidenceMasks& Segmentation::confidence_masks() const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.confidence_masks)
  return _internal_confidence_masks();
}
inline ::tflite::task::vision::Segmentation_ConfidenceMasks* Segmentation::unsafe_arena_release_confidence_masks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tflite.task.vision.Segmentation.confidence_masks)
  if (mask_oneof_case() == kConfidenceMasks) {
    clear_has_mask_oneof();
    ::tflite::task::vision::Segmentation_ConfidenceMasks* temp = _impl_.mask_oneof_.confidence_masks_;
    _impl_.mask_oneof_.confidence_masks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Segmentation::unsafe_arena_set_allocated_confidence_masks(::tflite::task::vision::Segmentation_ConfidenceMasks* confidence_masks) {
  clear_mask_oneof();
  if (confidence_masks) {
    set_has_confidence_masks();
    _impl_.mask_oneof_.confidence_masks_ = confidence_masks;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.task.vision.Segmentation.confidence_masks)
}
inline ::tflite::task::vision::Segmentation_ConfidenceMasks* Segmentation::_internal_mutable_confidence_masks() {
  if (mask_oneof_case() != kConfidenceMasks) {
    clear_mask_oneof();
    set_has_confidence_masks();
    _impl_.mask_oneof_.confidence_masks_ = CreateMaybeMessage< ::tflite::task::vision::Segmentation_ConfidenceMasks >(GetArenaForAllocation());
  }
  return _impl_.mask_oneof_.confidence_masks_;
}
inline ::tflite::task::vision::Segmentation_ConfidenceMasks* Segmentation::mutable_confidence_masks() {
  ::tflite::task::vision::Segmentation_ConfidenceMasks* _msg = _internal_mutable_confidence_masks();
  // @@protoc_insertion_point(field_mutable:tflite.task.vision.Segmentation.confidence_masks)
  return _msg;
}

// optional int32 width = 2;
inline bool Segmentation::has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Segmentation::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Segmentation::width() const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.width)
  return _internal_width();
}
inline void Segmentation::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:tflite.task.vision.Segmentation.width)
}
inline ::int32_t Segmentation::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Segmentation::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}

// optional int32 height = 3;
inline bool Segmentation::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Segmentation::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Segmentation::height() const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.height)
  return _internal_height();
}
inline void Segmentation::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tflite.task.vision.Segmentation.height)
}
inline ::int32_t Segmentation::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void Segmentation::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}

// repeated .tflite.task.vision.Segmentation.ColoredLabel colored_labels = 5;
inline int Segmentation::_internal_colored_labels_size() const {
  return _internal_colored_labels().size();
}
inline int Segmentation::colored_labels_size() const {
  return _internal_colored_labels_size();
}
inline void Segmentation::clear_colored_labels() {
  _internal_mutable_colored_labels()->Clear();
}
inline ::tflite::task::vision::Segmentation_ColoredLabel* Segmentation::mutable_colored_labels(int index) {
  // @@protoc_insertion_point(field_mutable:tflite.task.vision.Segmentation.colored_labels)
  return _internal_mutable_colored_labels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ColoredLabel >*
Segmentation::mutable_colored_labels() {
  // @@protoc_insertion_point(field_mutable_list:tflite.task.vision.Segmentation.colored_labels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_colored_labels();
}
inline const ::tflite::task::vision::Segmentation_ColoredLabel& Segmentation::colored_labels(int index) const {
  // @@protoc_insertion_point(field_get:tflite.task.vision.Segmentation.colored_labels)
    return _internal_colored_labels().Get(index);
}
inline ::tflite::task::vision::Segmentation_ColoredLabel* Segmentation::add_colored_labels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::tflite::task::vision::Segmentation_ColoredLabel* _add = _internal_mutable_colored_labels()->Add();
  // @@protoc_insertion_point(field_add:tflite.task.vision.Segmentation.colored_labels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::tflite::task::vision::Segmentation_ColoredLabel >&
Segmentation::colored_labels() const {
  // @@protoc_insertion_point(field_list:tflite.task.vision.Segmentation.colored_labels)
  return _internal_colored_labels();
}
inline const ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation_ColoredLabel>&
Segmentation::_internal_colored_labels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.colored_labels_;
}
inline ::google::protobuf::RepeatedPtrField<::tflite::task::vision::Segmentation_ColoredLabel>*
Segmentation::_internal_mutable_colored_labels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.colored_labels_;
}

inline bool Segmentation::has_mask_oneof() const {
  return mask_oneof_case() != MASK_ONEOF_NOT_SET;
}
inline void Segmentation::clear_has_mask_oneof() {
  _impl_._oneof_case_[0] = MASK_ONEOF_NOT_SET;
}
inline Segmentation::MaskOneofCase Segmentation::mask_oneof_case() const {
  return Segmentation::MaskOneofCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace vision
}  // namespace task
}  // namespace tflite


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tensorflow_5flite_5fsupport_2fcc_2ftask_2fvision_2fproto_2fsegmentations_2eproto_2epb_2eh
